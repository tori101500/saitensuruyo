# -*- coding: utf-8 -*-
"""ui刷新.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16_3dy1uiBK3wMZvJb-PEO4a9rLK66kCl
"""

# -*- coding: utf-8 -*-
"""ui刷新.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16_3dy1uiBK3wMZvJb-PEO4a9rLK66kCl
"""

# -*- coding: utf-8 -*-
"""
Moji Scan - 手書き文字書き起こしWebアプリ

Flaskを使用してWebサーバーを構築し、
アップロードされた手書き文字を含む画像をGoogleのGemini APIで解析し、
テキストに書き起こす
ngrokを利用して、Colab上で実行したWebアプリを一時的に外部公開する
"""

# 必要なライブラリをインストール
!pip install pyngrok flask google-generativeai opencv-python-headless -q

import io
import os
import textwrap
import numpy as np
from PIL import Image
import google.generativeai as genai
from IPython.display import display, HTML
from google.colab import files, userdata
from flask import Flask, request, render_template_string, redirect, url_for
from threading import Thread
import base64
from pyngrok import ngrok
import time
import cv2 # OpenCV for image pre-processing
import logging # ログ出力用のライブラリ

# アプリケーション全体のログ出力設定
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Google Colab SecretsからAPIキーとngrokトークンを取得
try:
    API_KEY = userdata.get('GEMINI_API_KEY1')
    NGROK_AUTH_TOKEN = userdata.get('NGROK_AUTH_TOKEN')
    if not API_KEY:
        raise ValueError("GEMINI_API_KEY が Colab Secrets に設定されていません。")
    if not NGROK_AUTH_TOKEN:
        raise ValueError("NGROK_AUTH_TOKEN が Colab Secrets に設定されていません。")
except Exception as e:
    logging.error(f"エラー: {e}")
    logging.error("Colab の左側にある鍵のアイコン (Secrets) をクリックし、'GEMINI_API_KEY' と 'NGROK_AUTH_TOKEN' を設定してください。")
    logging.error("設定後、'Notebook access' をオンにしてください。")
    exit() # シークレットが設定されていない場合は終了

# Gemini API の設定
genai.configure(api_key=API_KEY)

# Flaskアプリケーションを初期化
app = Flask(__name__)

# 使用するGeminiモデル
model = genai.GenerativeModel('gemini-2.0-flash')

# アプリケーションの状態を管理するグローバル変数を定義
global_uploaded_image_b64 = None
global_processing_result_text = None # 書き起こしテキストのみを格納
global_processing_status = None # ステータスを別に格納
global_is_processing = False # 処理中フラグを追加

# HTMLテンプレート (★ここからCSSのボタン色をグレーに変更)
HTML_TEMPLATE = """
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Moji Scan</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Noto Sans JP', sans-serif;
            background-color: #f0f2f5;
            color: #1c1e21;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            box-sizing: border-box;
        }
        .container {
            background-color: #ffffff;
            padding: 40px;
            border-radius: 4px;
            border: 1px solid #ddd;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.07);
            width: 90%;
            max-width: 800px;
            box-sizing: border-box;
            text-align: center;
        }
        h1 {
            color: #1c1e21;
            margin-bottom: 30px;
            font-weight: 700;
        }
        .upload-section {
            margin-bottom: 30px;
            border: 2px dashed #ccd0d5;
            background-color: #f5f6f7;
            padding: 30px;
            border-radius: 4px;
            transition: background-color 0.3s ease;
        }
        .upload-section p {
            color: #4b4f56;
            margin-top: 0;
            margin-bottom: 20px;
        }
        input[type="file"] {
            display: none;
        }
        .custom-file-upload {
            border: none;
            display: inline-block;
            padding: 12px 25px;
            cursor: pointer;
            border-radius: 4px;
            background-color: #343a40; /* ★ダークグレーに変更 */
            color: white;
            font-weight: 500;
            font-size: 16px;
            transition: background-color 0.2s ease;
            box-shadow: none;
        }
        .custom-file-upload:hover {
            background-color: #23272b; /* ★より濃いグレーに変更 */
            transform: none;
        }
        img.uploaded-image {
            max-width: 100%;
            height: auto;
            border-radius: 4px;
            margin-top: 20px;
            border: 1px solid #ddd;
        }
        .results-section {
            margin-top: 30px;
            padding-top: 30px;
            border-top: 1px solid #ddd;
            text-align: left;
        }
        h2 {
            color: #1c1e21;
            margin-bottom: 20px;
        }
        pre {
            background-color: #f5f6f7;
            color: #1c1e21;
            padding: 20px;
            border-radius: 4px;
            white-space: pre-wrap;
            word-wrap: break-word;
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid #e0e0e0;
            line-height: 1.7;
        }
        .loading {
            color: #ff9900;
            font-size: 1.2em;
            margin-top: 20px;
        }
        .error {
            color: #d93025;
            margin-top: 20px;
            background-color: #fbe2e2;
            padding: 10px;
            border-radius: 4px;
            border: 1px solid #d93025;
        }
        .note {
            font-size: 0.9em;
            color: #606770;
            margin-top: 15px;
        }
        .footer {
            margin-top: 40px;
            font-size: 0.9em;
            color: #606770;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Moji Scan</h1>
        {% if processing %}
            <div class="upload-section">
                {% if image_data %}<img src="data:image/jpeg;base64,{{ image_data }}" alt="Uploaded Image" class="uploaded-image">{% endif %}
                <p class="loading">{{ status_message | default('画像を処理中です...しばらくお待ちください。') }}</p>
            </div>
            <script>setTimeout(function(){ location.reload(true); }, 3000);</script>
        {% elif result_text is not none %}
            <div class="results-section">
                <h2>書き起こし結果</h2>
                {% if image_data %}<img src="data:image/jpeg;base64,{{ image_data }}" alt="Uploaded Image" class="uploaded-image" style="max-width: 300px; margin-bottom: 20px; display: block; margin-left: auto; margin-right: auto;">{% endif %}
                <pre>{{ result_text }}</pre>
                {% if status_message %}<p class="note"><b>処理ステータス:</b> {{ status_message }}</p>{% endif %}
                <p class="note">上記はGeminiによる書き起こし結果です。</p>
                <button onclick="window.location.href='/'" class="custom-file-upload" style="margin-top: 20px; display: block; margin-left: auto; margin-right: auto;">新しい画像をアップロード</button>
            </div>
        {% else %}
            <div class="upload-section">
                <p>手書き文字を書き起こせるツールです。画像をアップロードしてください。</p>
                <form action="/upload" method="post" enctype="multipart/form-data">
                    <label for="image_file" class="custom-file-upload">ファイルを選択</label>
                    <input type="file" name="image_file" id="image_file" accept="image/*" onchange="this.form.submit()">
                </form>
                {% if message %}<p class="error">{{ message }}</p>{% endif %}
            </div>
        {% endif %}
    </div>
    <div class="footer">powerd by Google Gemini API</div>
</body>
</html>
"""

# Geminiへのプロンプトを定義
PROMPT_BASE = """
この画像に含まれる手書きの文字を、可能な限り正確に全て書き起こしてください。
文字のかすれ、にじみ、傾き、または判読しにくい部分があっても、文脈から最も適切と思われる内容を推測し、テキストとして出力してください。
句読点や改行も元の手書き文字に忠実に再現してください。
書き起こし以外の、画像に関する説明やコメント、補足情報は一切含めないでください。
結果は純粋なテキスト形式で提供してください。
"""
PROMPT_VARIANT = """
画像内の手書き文字を完全に書き起こしてください。
誤字脱字、判読困難な文字があった場合でも、その文字の意図を汲み取り、もっともらしいテキストに変換してください。
出力には、書き起こされたテキストのみを含め、それ以外の説明やコメントは一切含めないでください。
"""
FINAL_JUDGEMENT_PROMPT = """
あなたは非常に優秀な編集者です。これから、一つの手書き画像に対して行った、複数のOCR（文字認識）結果を提示します。
これらのOCR結果には、それぞれわずかな誤りや解釈の違いが含まれている可能性があります。

提示された複数のOCR結果と、元の画像を注意深く見比べてください。
そして、全ての情報を統合し、最も正確で、元の手書きの意図を完璧に反映した**最終的な書き起こしテキストを一つだけ生成してください。**

- 元の画像の改行、箇条書きのスタイル（番号や記号）を忠実に再現してください。
- 余計な説明、前置き、コメントは一切不要です。
- 最終的な書き起こしテキストのみを出力してください。

---
【OCR結果1】
{text1}
---
【OCR結果2】
{text2}
---

上記の指示に従い、元の画像から最終的な書き起こしテキストを生成してください。
"""

# 画像をリサイズし、前処理を行う関数
def resize_and_preprocess_image(image_bytes, max_dim=1024):
    """
    画像をリサイズし、バイト形式で返す。（ノイズ除去と二値化処理は意図的に無効化）
    最大辺がmax_dimを超える場合、アスペクト比を維持して縮小する。
    """
    try:
        # PILで画像を開く
        img_pil = Image.open(io.BytesIO(image_bytes))
        if img_pil.mode != 'RGB':
            img_pil = img_pil.convert('RGB')

        # PILイメージをOpenCV形式に変換
        img_cv = np.array(img_pil)
        img_cv = cv2.cvtColor(img_cv, cv2.COLOR_RGB2BGR)

        # 現在のスクリプトは発表用のため画像補正処理を無効化
        # # 1. ノイズ除去: ガウシアンブラー
        # img_cv = cv2.GaussianBlur(img_cv, (5, 5), 0)
        # # 2. 二値化: グレースケール変換後、大津の二値化を適用
        # gray = cv2.cvtColor(img_cv, cv2.COLOR_BGR2GRAY)
        # _, img_binarized = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)
        # img_cv = cv2.cvtColor(img_binarized, cv2.COLOR_GRAY2BGR) # Geminiに渡すためにBGRに戻す

        # 画像のリサイズ処理
        height, width = img_cv.shape[:2]
        if max(width, height) > max_dim:
            if width > height:
                new_width = max_dim
                new_height = int(height * (max_dim / width))
            else:
                new_height = max_dim
                new_width = int(width * (max_dim / height))
            img_cv = cv2.resize(img_cv, (new_width, new_height), interpolation=cv2.INTER_LANCZOS4)

        # OpenCVイメージをPIL形式に戻し、バイトデータとして返す
        img_pil_resized = Image.fromarray(cv2.cvtColor(img_cv, cv2.COLOR_BGR2RGB))
        buffered = io.BytesIO()
        img_pil_resized.save(buffered, format="JPEG")
        return buffered.getvalue()
    except Exception as e:
        logging.error(f"Error during image resizing/pre-processing: {e}")
        # 前処理に失敗した場合、リサイズのみ試みる
        try:
            img_pil = Image.open(io.BytesIO(image_bytes))
            if img_pil.mode != 'RGB':
                img_pil = img_pil.convert('RGB')
            width, height = img_pil.size
            if max(width, height) > max_dim:
                if width > height:
                    new_width = max_dim
                    new_height = int(height * (max_dim / width))
                else:
                    new_height = max_dim
                    new_width = int(width * (max_dim / height))
                img_pil_resized = img_pil.resize((new_width, new_height), Image.LANCZOS)
            else:
                img_pil_resized = img_pil
            buffered = io.BytesIO()
            img_pil_resized.save(buffered, format="JPEG")
            return buffered.getvalue()
        except Exception as resize_e:
            logging.error(f"Fallback resize failed: {resize_e}")
            return image_bytes # リサイズも失敗したら元の画像を返す

# Gemini APIにリクエストを送り、レスポンスを取得する関数
def get_gemini_response(image_bytes, prompt):
    try:
        image = Image.open(io.BytesIO(image_bytes))
        response = model.generate_content([prompt, image])
        if response._result.candidates and response._result.candidates[0].content.parts:
            return response._result.candidates[0].content.parts[0].text.strip()
        return "Geminiからの応答がありませんでした。"
    except Exception as e:
        logging.error(f"Error in Gemini response: {e}")
        if "quota" in str(e).lower() or "429" in str(e):
            return "Geminiからの応答中にエラーが発生しました: クォータ制限に達しました。しばらく時間をおいてから再試行してください。詳細はエラーログを確認してください。"
        elif "blocked" in str(e).lower() or "safety" in str(e).lower():
            return "Geminiからの応答が安全上の理由によりブロックされました。画像の内容を確認してください。"
        return f"Geminiからの応答中にエラーが発生しました: {e}"

# Webページの各URLに対応する処理を定義 (ルーティング)
@app.route('/', methods=['GET'])
def index():
    global global_processing_result_text, global_processing_status, global_uploaded_image_b64, global_is_processing

    # 処理中であれば、ローディング画面を表示
    if global_is_processing:
        return render_template_string(HTML_TEMPLATE,
                                      processing=True,
                                      image_data=global_uploaded_image_b64,
                                      status_message=global_processing_status)

    # 処理完了後、結果表示画面を表示
    result_text_to_display = global_processing_result_text
    status_message_to_display = global_processing_status
    image_data_to_display = global_uploaded_image_b64

    # 一度表示したら、次回のアクセスのためにグローバル変数をリセット
    global_processing_result_text = None
    global_processing_status = None
    global_uploaded_image_b64 = None
    global_is_processing = False

    return render_template_string(HTML_TEMPLATE,
                                  result_text=result_text_to_display,
                                  status_message=status_message_to_display,
                                  image_data=image_data_to_display)

@app.route('/upload', methods=['POST'])
def upload_file():
    global global_uploaded_image_b64, global_processing_result_text, global_processing_status, global_is_processing

    if 'image_file' not in request.files:
        return render_template_string(HTML_TEMPLATE, message="ファイルが選択されていません。")
    file = request.files['image_file']
    if file.filename == '':
        return render_template_string(HTML_TEMPLATE, message="ファイルが選択されていません。")
    if file:
        original_image_bytes = file.read()

        # 画像をリサイズし、前処理を適用
        resized_image_bytes = resize_and_preprocess_image(original_image_bytes)

        # グローバル変数を更新し、処理中状態に設定
        global_uploaded_image_b64 = base64.b64encode(resized_image_bytes).decode('utf-8')
        global_processing_result_text = None
        global_processing_status = "画像をアップロードしました。処理を開始します。"
        global_is_processing = True

        # 時間のかかる画像処理を別スレッドで実行
        processing_thread = Thread(target=process_image_background, args=(resized_image_bytes,))
        processing_thread.daemon = True
        processing_thread.start()

        # すぐにリダイレクトしてローディング画面を表示
        return redirect(url_for('index'))
    else:
        return render_template_string(HTML_TEMPLATE, message="画像のアップロードに失敗しました。")


# 画像の書き起こし処理をバックグラウンドで実行する関数
def process_image_background(image_bytes):
    """
    バックグラウンドでGeminiによる画像解析を行う。
    2つの異なるプロンプトで解析し、結果が異なれば、最終判断を再度AIに委ねる。
    """
    global global_processing_result_text, global_processing_status, global_is_processing

    try:
        logging.info("バックグラウンド処理開始...")
        image_pil = Image.open(io.BytesIO(image_bytes))

        # ステップ1: 異なるプロンプトで2つの書き起こし候補を生成
        global_processing_status = "Geminiモデルが手書き文字を解析中です (候補1/2)..."
        response1_text = get_gemini_response(image_bytes, PROMPT_BASE)
        logging.info(f"候補1の結果: '{response1_text}'")
        if "エラーが発生しました" in response1_text or "ブロックされました" in response1_text:
            raise Exception(f"候補1の生成に失敗: {response1_text}")

        global_processing_status = "Geminiモデルが手書き文字を解析中です (候補2/2)..."
        response2_text = get_gemini_response(image_bytes, PROMPT_VARIANT)
        logging.info(f"候補2の結果: '{response2_text}'")
        if "エラーが発生しました" in response2_text or "ブロックされました" in response2_text:
            raise Exception(f"候補2の生成に失敗: {response2_text}")

        # ステップ2: 2つの結果が完全に一致すれば、それで処理完了
        if response1_text.strip() == response2_text.strip():
            logging.info("2つの候補が完全に一致しました。処理を完了します。")
            final_result_text = response1_text
            status_message = "2回の解析結果が完全に一致しました。"
        else:
            # ステップ3: 結果が異なる場合、AIに最終判断を依頼
            global_processing_status = "解析結果の候補を比較し、最終版を生成中です..."
            logging.info("結果が不一致のため、最終判断をGeminiに依頼します。")
            final_prompt = FINAL_JUDGEMENT_PROMPT.format(text1=response1_text, text2=response2_text)

            final_response = model.generate_content([final_prompt, image_pil])

            if final_response._result.candidates and final_response._result.candidates[0].content.parts:
                final_result_text = final_response._result.candidates[0].content.parts[0].text.strip()
                status_message = "複数の解析結果を基に、Geminiが最終的なテキストを生成しました。"
                logging.info(f"最終結果: '{final_result_text}'")
            else:
                # 最終判断に失敗した場合のフォールバック処理
                logging.warning("最終判断の応答がありませんでした。候補1を結果として採用します。")
                final_result_text = response1_text
                status_message = "最終判断に失敗したため、最初の解析結果を採用しました。"

        global_processing_result_text = final_result_text
        global_processing_status = status_message

    except Exception as e:
        logging.error(f"バックグラウンド処理中にエラーが発生しました: {e}", exc_info=True)
        global_processing_result_text = f"処理中にエラーが発生しました: {e}"
        global_processing_status = "処理失敗"
    finally:
        # 処理が成功しても失敗しても、処理中フラグを解除
        global_is_processing = False

# Flaskアプリを起動し、ngrokで外部公開する処理
def run_flask_app():
    # Flaskアプリをローカルで実行
    app.run(host='0.0.0.0', port=os.environ.get('PORT', 5000), debug=False)

# このスクリプトが直接実行された場合のメイン処理
if __name__ == '__main__':
    if not NGROK_AUTH_TOKEN:
        logging.error("エラー: NGROK_AUTH_TOKEN が Colab Secrets に設定されていません。")
    else:
        # Flaskアプリをバックグラウンドで起動
        thread = Thread(target=run_flask_app)
        thread.daemon = True
        thread.start()

        time.sleep(2) # Flaskアプリが起動するのを待つ

        # ngrokでローカルサーバーを外部に公開
        ngrok.set_auth_token(NGROK_AUTH_TOKEN)
        try:
            public_url = ngrok.connect(5000)
            logging.info(f"Colab Webアプリが公開されました: {public_url}")
            print(f"Colab Webアプリが公開されました: {public_url}")
            print("上記URLにアクセスしてください。")
            # アプリケーションが終了しないように待機
            while True:
                time.sleep(1)
        except Exception as e:
            logging.error(f"ngrokの起動に失敗しました: {e}")
            print(f"ngrokの起動に失敗しました: {e}")
            print("ngrok認証トークンが正しく設定されているか、または有効期限が切れていないか確認してください。")